\chapter{Perspetiva de Solução}\label{chap:chap3}

\section*{}

Com base nas informações recolhidas durante a revisão bibliográfica e algum estudo feito entretanto, temos já uma perspetiva de solução que deverá permitir atingir os objetivos propostos.

Sendo o objetivo melhorar a ordenação de resultados do \emph{Barinel/Crowbar}, através do cálculo da \emph{component goodness}, com base em dados retirados do histórico do projeto, percebemos que estamos perante um problema de classificação (\emph{Machine Learning}). 
Esta classificação terá como objetivo categorizar cada um dos componentes como \emph{buggy} (com defeito) ou \emph{clean} (sem defeito).

Baseando-nos nos resultados obtidos pelo \emph{Change Classification}, achamos pertinente começar por identificar as alterações (\emph{commits}) que correspondem a correções, através da mensagem descritiva associada.
A partir desta identificação, pretendemos extrair as informações relativas a cada um dos componentes no momento anterior à sua correção. As informações a extrair terão ainda de ser elegidas, mas deverão envolver os seguintes dados:
%
\begin{itemize}
	\item Existência de erros (considerar-se-á que os componentes alterados durante a correção correspondem aos componentes defeituosos).
	\item Data de alterações anteriormente.
	\item \emph{Usernames} dos últimos contribuidores.
	\item Complexidade e número de linhas de código do componente.
	\item Existência de comentários no código indicando necessidade de trabalhos futuros.
\end{itemize}

Após esta extração de informações do \emph{Git}, estes dados terão de ser processados para permitir a criação de um modelo de classificação que seja capaz de representar os componentes da forma que pretendemos. Um dos processamentos que possivelmente terá de ser efetuado é relativo às datas de alterações, pois pretende-se um valor que represente se o componente tem vindo ou não a ser modificado diversas vezes. Para este exemplo considera-se o uso de uma função que considera, através da atribuição de pesos, como mais relevante as alterações que tenham uma data mais próxima da sua correção.

Tendo os dados sido devidamente extraídos e processados para cada componente de cada correção feita durante o decorrer do projeto, tenciona-se usar um dos seguintes algoritmos de \emph{Machine Learning}:
%
\begin{itemize}
	\item \emph{Naïve Bayes}.
	\item \emph{Support Vector Machines}.
	\item \emph{Random Forests}.
\end{itemize}

Obtendo no final para cada componente uma previsão de existência ou não de erro, associada a uma confiança, que será convertida para um valor real de 0 a 1. Em que 1 corresponde à não existência de erros (qualidade máxima) e 0 corresponde à certeza de existência de erros. Este valor, a \emph{component goodness}, será então utilizado pelo \emph{Barinel/Crowbar} para calcular a probabilidade de cada candidato, sem recurso exclusivo ao algoritmo de \emph{Maximum Likehood Estimation}.


\subsection{Possíveis dificuldades}

Identificamos à partida algumas dificuldades e problemas que poderão surgir durante a realização do trabalho:
%
\begin{itemize}
	\item Poderá não ser possível em tempo razoável conseguir extrair do repositório \emph{Git} toda a informação de que necessitamos.
	\item Em alguns projetos a identificação das correções pode não ser muito precisa, devido a mensagens pouco descritivas.
	\item Classificar todos os componentes que não foram alterados na correção como \emph{clean} poderá não ser o mais correto e afetar negativamente a criação do modelo. Isto porque poderão haver componentes que não foram modificados na altura, mas que mesmo assim contém erros ainda não corrigidos ou identificados.
	\item Havendo um número muito superior de componentes à partida classificados como \emph{clean} (sem erros) poderá haver a tendência do modelo classificar erradamente componentes \emph{buggy}.
	\item Poderá ser demonstrado que mesmo obtendo um valor de \emph{component goodness} representativo, o algoritmo \emph{Barinel} apresente melhores resultados continuando a recorrer ao algoritmo de maximização MLE.
\end{itemize}