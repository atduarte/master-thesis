\chapter{Revisão Bibliográfica} \label{chap:sota}

\section*{}

Neste capítulo é feita uma revisão bibliográfica e descrito o estado da arte do \emph{software} de localização de falhas, como o Barinel, das diferentes abordagens de predição de defeitos e ainda de \emph{Software Repository Mining}.

\section{\emph{Fault Localization Software}}

O \emph{Fault Localization Software} auxilia na localização automática do código que origina falhas na sua execução, diminuindo o custo desta identificação que teria de ser feita manualmente pelo programador. Existem duas categorias principais: \emph{Program-spectra based} e \emph{Model-based diagnosis} (MDB).

% 
% ==========
% Program-spectra based
% ==========
%

\subsection{\emph{Program-spectra based}}

% 
% ==========
% Model-based diagnosis
% ==========
%

\subsection{\emph{Model-based diagnosis}}

% 
% ==========
% Barinel
% ==========
%

\subsection{\emph{Barinel}}

O \emph{Barinel} é um algoritmo que se inspira nos dois métodos descritos anteriormente, \emph{program-spectra based} e \emph{model-based diagnosis}, e que com isto consegue melhores resultados que as outras soluções com um custo pouco superior \cite{Abreu2009}.

O algoritmo começa por analisar uma \emph{hit-spectra matrix}, que representa os testes executados em relação aos componentes que foram executados e ao seu resultado final.

\begin{table}[]
	\centering
	\begin{tabular}{c|ccc|c} 
		& \multicolumn{3}{c|}{\textit{obs}} &  \\
		& $c_1$ & $c_2$ & $c_3$ & e \\ 
	 	\hline
		$t_1$ & 1 & 1 & 0 & 1 \\
		$t_2$ & 0 & 1 & 1 & 1 \\
		$t_3$ & 1 & 0 & 0 & 1 \\
		$t_4$ & 1 & 0 & 1 & 0 \\
	\end{tabular}
	\caption{\emph{Hit-spectra matrix}}
	\label{tab:hit-spectra}
\end{table}


Na tabela \ref{tab:hit-spectra}, temos identificados 3 componentes distintos ($c_1$, $c_2$ e $c_3$), 4 testes executados ($t_1$, $t_2$, $t_3$ e $t_4$) e o respectivo resultado da execução ($e$). O valor 1 em qualquer uma das colunas das observações (\emph{obs}) indica que o dado componente foi executado nesse teste e o valor 0 indica o contrário, que o componente não foi executado. Na coluna $e$, o algarismo 1 declara que o teste correspondente falhou. 
Pelo que, por exemplo, o teste $t_4$ executou os componentes $c_1$ e $c_3$ e foi concluído com sucesso.


% 
% Geração de candidatos
%

\subsubsection{Geração de candidatos} 

Com base nesta matriz, uma lista de conjuntos de candidados ($d$) é gerada, sendo esta reduzida ao número mínimo de candidatos possível. 

Neste caso, seriam gerados apenas dois candidatos:

\begin{itemize}
\item $d_1 = \{c_1, c_2\}$ 
\item $d_2 = \{c_1, c_3\}$ 
\end{itemize}

% 
% Ordenação de candidatos
%

\subsubsection{Ordenação de candidatos} 

Para cada candidato $d$, é calculada a probabilidade de acordo com a regra de \emph{Naïve Bayes}:

% TODO!!
\textbf{\textcolor{red}{TODO $Pr(d | obs, e)$} }

$Pr(obs_i)$ é apenas um termo normalizador idêntico para todos os candidatos, pelo que não é usado para proceder à ordenação.

Sendo $p_j$ a probabilidade à \emph{priori} do componente $c_j$ originar uma falha, podemos definir $Pr(d)$, probabilidade do candidato ser responsável pelo erro, não tendo em conta evidências adicionais, como

% TODO - Label da figura...
$$ Pr(d) = \prod_{j \in d} p_j \cdot \prod_{j \notin d} (1 - p_j) $$

Sendo $g_j$ (\emph{component goodness}) a probabilidade do componente $c_j$ executar de forma correta, temos que

% TODO!!
\textbf{\textcolor{red}{TODO $Pr(obs_i, e_i | d)$} }

Tendo em conta o nosso exemplo

% TODO!!
\textbf{\textcolor{red}{TODO $Pr(d_1, obs_i, e_i)$} }
\textbf{\textcolor{red}{TODO $Pr(d_2, obs_i, e_i)$} }

Quando existem valores $g_j$ desconhecidos, é maximizado o valor de $Pr(obs, e | d)$ usando o algoritmo \emph{Maximum Likelyhood Estimation} (MLE).

Neste caso, todos os valores de $g_j$ são desconhecidos. Executando o algoritmo MLE para ambas as funções e calculando o resultado final temos que:


\begin{itemize}
\item $Pr(d_1, obs, e) = 1.9 \times 10^{-9}$\ \ ($g_1 = 0.47$ e $g_2 = 0.19$)
\item $Pr(d_2, obs, e) = 4.0 \times 10^{-10}$ ($g_1 = 0.41$ e $g_3 = 0.50$)
\end{itemize}


% 
% ==========
% Crowbar
% ==========
%

\subsection{\emph{Crowbar}}

% TODO: Devo traduzir
\section{\emph{Software Repository Mining}}

Identificação de bugs - Erros
libgit2
node-git

% TODO: Devo traduzir
\section{Abordagens à predição de defeitos}


\subsection{\emph{BugCache}}

\subsection{\emph{FixCache}}

\subsection{\emph{Buggy Change Classification}}


Time-weighted Risk
WhoseFault
History slicing/Chronos
SZZ
Machine Learning Classification:
- Naive Bayes
- SVM
- Random Forests